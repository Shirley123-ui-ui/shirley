<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®Œå–„ç‰ˆï¼šç”µåœºä¸é«˜æ–¯å®šç†3Dæ¼”ç¤ºï¼ˆå¢åŠ çƒå£³å’Œåœ†æŸ±å£³ï¼‰</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0c2461, #1e3799);
            color: #fff;
            overflow: hidden;
            height: 100vh;
        }
        #container { display: flex; height: 100vh; }
        #sidebar {
            width: 380px;
            background: rgba(25, 42, 86, 0.95);
            padding: 25px;
            overflow-y: auto;
            border-right: 3px solid #3498db;
        }
        #title {
            color: #3498db;
            font-size: 1.8em;
            margin-bottom: 10px;
            padding-bottom: 15px;
            border-bottom: 2px solid #2980b9;
            text-align: center;
        }
        #subtitle {
            text-align: center;
            color: #bdc3c7;
            margin-bottom: 25px;
            font-size: 0.95em;
        }
        .section {
            background: rgba(41, 128, 185, 0.15);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
            border-left: 4px solid #3498db;
        }
        .section-title {
            color: #2ecc71;
            font-size: 1.3em;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        .section-title::before {
            content: 'â–¶';
            margin-right: 10px;
            font-size: 0.8em;
        }
        select, button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: #2c3e50;
            color: white;
            border: 2px solid #3498db;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
        }
        button.primary { background: linear-gradient(135deg, #3498db, #2980b9); font-weight: bold; }
        button.secondary { background: linear-gradient(135deg, #2ecc71, #27ae60); }
        .control-group { margin-bottom: 15px; }
        .control-label {
            display: block;
            color: #ecf0f1;
            margin-bottom: 8px;
            font-weight: 500;
        }
        .charge-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        input[type="range"] {
            flex: 1;
            height: 8px;
            background: #34495e;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
        }
        /* æ­£ç”µè·æ»‘å—æ ·å¼ */
        input[type="range"].positive-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: #e74c3c; /* çº¢è‰²ä»£è¡¨æ­£ç”µè· */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.8);
        }
        /* è´Ÿç”µè·æ»‘å—æ ·å¼ */
        input[type="range"].negative-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: #3498db; /* è“è‰²ä»£è¡¨è´Ÿç”µè· */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.8);
        }
        /* é›¶ç”µè·æ»‘å—æ ·å¼ */
        input[type="range"].zero-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 22px;
            height: 22px;
            background: #95a5a6; /* ç°è‰²ä»£è¡¨é›¶ç”µè· */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(149, 165, 166, 0.8);
        }
        .value-display {
            min-width: 80px;
            background: rgba(52, 152, 219, 0.2);
            padding: 6px 12px;
            border-radius: 6px;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        .pos-value { color: #e74c3c; } /* æ­£å€¼æ˜¾ç¤ºçº¢è‰² */
        .neg-value { color: #3498db; } /* è´Ÿå€¼æ˜¾ç¤ºè“è‰² */
        .zero-value { color: #95a5a6; } /* é›¶å€¼æ˜¾ç¤ºç°è‰² */
        #visualization { flex: 1; position: relative; overflow: hidden; }
        #canvas-container { width: 100%; height: 100%; }
        .data-panel {
            background: rgba(44, 62, 80, 0.9);
            border-radius: 10px;
            padding: 18px;
            margin-top: 20px;
            border: 2px solid #2ecc71;
        }
        .data-row {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .data-label { color: #bdc3c7; }
        .data-value {
            color: #f1c40f;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        .gauss-proof {
            font-family: 'Cambria Math', serif;
            font-size: 1em;
            text-align: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 5px;
            border-left: 3px solid #e74c3c;
        }
        .legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 20px;
            font-size: 0.85em;
        }
        .legend-item {
            display: flex;
            align-items: center;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            border-radius: 3px;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5em;
            color: #3498db;
        }
        #instructions {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 0.9em;
            z-index: 50;
        }
        .warning {
            color: #ff9800;
            font-size: 0.85em;
            margin-top: 5px;
            padding: 5px;
            background: rgba(255, 152, 0, 0.1);
            border-radius: 4px;
            border-left: 3px solid #ff9800;
        }
        .info {
            color: #4CAF50;
            font-size: 0.85em;
            margin-top: 5px;
            padding: 5px;
            background: rgba(76, 175, 80, 0.1);
            border-radius: 4px;
            border-left: 3px solid #4CAF50;
        }
        .special-info {
            color: #9b59b6;
            font-size: 0.85em;
            margin-top: 5px;
            padding: 5px;
            background: rgba(155, 89, 182, 0.1);
            border-radius: 4px;
            border-left: 3px solid #9b59b6;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="sidebar">
            <h1 id="title">âš¡ å®Œå–„ç‰ˆï¼šç”µåœºä¸é«˜æ–¯å®šç†3Dæ¼”ç¤º</h1>
            <div id="subtitle">å¢åŠ å¸¦ç”µçƒå£³å’Œå¸¦ç”µåœ†æŸ±å£³æ¨¡å—</div>

            <div class="section">
                <h2 class="section-title">ğŸ”Œ é€‰æ‹©å¸¦ç”µä½“ç±»å‹</h2>
                <select id="chargeType">
                    <option value="point">ç‚¹ç”µè·</option>
                    <option value="sphere">å‡åŒ€å¸¦ç”µçƒä½“</option>
                    <option value="sphereShell">å¸¦ç”µçƒå£³</option>
                    <option value="cylinder">æ— é™é•¿å¸¦ç”µåœ†æŸ±ä½“</option>
                    <option value="cylinderShell">å¸¦ç”µåœ†æŸ±å£³</option>
                    <option value="plane">æ— é™å¤§å¸¦ç”µå¹³é¢</option>
                </select>
                <button class="primary" id="resetView">ğŸ”„ é‡ç½®è§†å›¾</button>
                <button class="secondary" id="toggleFieldLines">ç”µåœºçº¿: <span id="fieldLineStatus">æ˜¾ç¤º</span></button>
                <button class="secondary" id="toggleGaussian">é«˜æ–¯é¢: <span id="gaussianStatus">æ˜¾ç¤º</span></button>
            </div>

            <div class="section">
                <h2 class="section-title">ğŸšï¸ ç”µè·å‚æ•°è°ƒèŠ‚ (å¯æ­£å¯è´Ÿ)</h2>

                <div class="control-group" id="pointSphereControls">
                    <div class="control-label">
                        <span class="charge-indicator" id="QIndicator" style="background:#e74c3c"></span>
                        ç”µè·é‡ Q (Ã—10â»â¹ C)
                    </div>
                    <div class="slider-container">
                        <input type="range" id="QSlider" class="positive-range" min="-3" max="3" step="0.1" value="1">
                        <span class="value-display">
                            <span id="QValue" class="pos-value">+1.0</span>
                        </span>
                    </div>
                    <div class="control-group" id="sphereRadiusControl">
                        <div class="control-label" id="radiusLabel">çƒä½“åŠå¾„ R (m)</div>
                        <div class="slider-container">
                            <input type="range" id="RSlider" min="0.3" max="2" step="0.1" value="1">
                            <span class="value-display" id="RValue">1.0</span>
                        </div>
                    </div>
                    <div class="control-label">é«˜æ–¯é¢åŠå¾„ (m)</div>
                    <div class="slider-container">
                        <input type="range" id="gaussSphereSlider" min="0.1" max="4" step="0.1" value="2">
                        <span class="value-display" id="gaussSphereValue">2.0</span>
                    </div>
                </div>

                <div class="control-group" id="sphereShellControls" style="display:none;">
                    <div class="control-label">
                        <span class="charge-indicator" id="QShellIndicator" style="background:#e74c3c"></span>
                        çƒå£³ç”µè·é‡ Q (Ã—10â»â¹ C)
                    </div>
                    <div class="slider-container">
                        <input type="range" id="QShellSlider" class="positive-range" min="-3" max="3" step="0.1" value="1">
                        <span class="value-display">
                            <span id="QShellValue" class="pos-value">+1.0</span>
                        </span>
                    </div>
                    <div class="control-label">çƒå£³åŠå¾„ R (m)</div>
                    <div class="slider-container">
                        <input type="range" id="sphereShellRSlider" min="0.3" max="2" step="0.1" value="1">
                        <span class="value-display" id="sphereShellRValue">1.0</span>
                    </div>
                    <div class="control-label">é«˜æ–¯é¢åŠå¾„ (m)</div>
                    <div class="slider-container">
                        <input type="range" id="gaussSphereShellSlider" min="0.1" max="4" step="0.1" value="2">
                        <span class="value-display" id="gaussSphereShellValue">2.0</span>
                    </div>
                    <div class="special-info">
                        âš¡ ç”µè·åªåˆ†å¸ƒåœ¨çƒå£³è¡¨é¢<br>
                        ğŸ“Š çƒå£³å†…éƒ¨ç”µåœºä¸ºé›¶ï¼Œé«˜æ–¯é¢åœ¨å†…éƒ¨æ—¶ç”µé€šé‡ä¸ºé›¶
                    </div>
                </div>

                <div class="control-group" id="cylinderControls" style="display:none;">
                    <div class="control-label">
                        <span class="charge-indicator" id="lambdaIndicator" style="background:#e74c3c"></span>
                        çº¿ç”µè·å¯†åº¦ Î» (Ã—10â»â¹ C/m)
                    </div>
                    <div class="slider-container">
                        <input type="range" id="lambdaSlider" class="positive-range" min="-2" max="2" step="0.1" value="1">
                        <span class="value-display">
                            <span id="lambdaValue" class="pos-value">+1.0</span>
                        </span>
                    </div>
                    <div class="control-label">åœ†æŸ±åŠå¾„ (m)</div>
                    <div class="slider-container">
                        <input type="range" id="cylinderRSlider" min="0.2" max="1.5" step="0.1" value="0.5">
                        <span class="value-display" id="cylinderRValue">0.5</span>
                    </div>
                    <div class="control-label">é«˜æ–¯é¢åŠå¾„ (m)</div>
                    <div class="slider-container">
                        <input type="range" id="gaussCylinderSlider" min="0.1" max="3" step="0.1" value="1.5">
                        <span class="value-display" id="gaussCylinderValue">1.5</span>
                    </div>
                </div>

                <div class="control-group" id="cylinderShellControls" style="display:none;">
                    <div class="control-label">
                        <span class="charge-indicator" id="lambdaShellIndicator" style="background:#e74c3c"></span>
                        åœ†æŸ±å£³çº¿ç”µè·å¯†åº¦ Î» (Ã—10â»â¹ C/m)
                    </div>
                    <div class="slider-container">
                        <input type="range" id="lambdaShellSlider" class="positive-range" min="-2" max="2" step="0.1" value="1">
                        <span class="value-display">
                            <span id="lambdaShellValue" class="pos-value">+1.0</span>
                        </span>
                    </div>
                    <div class="control-label">åœ†æŸ±å£³åŠå¾„ (m)</div>
                    <div class="slider-container">
                        <input type="range" id="cylinderShellRSlider" min="0.2" max="1.5" step="0.1" value="0.5">
                        <span class="value-display" id="cylinderShellRValue">0.5</span>
                    </div>
                    <div class="control-label">é«˜æ–¯é¢åŠå¾„ (m)</div>
                    <div class="slider-container">
                        <input type="range" id="gaussCylinderShellSlider" min="0.1" max="3" step="0.1" value="1.5">
                        <span class="value-display" id="gaussCylinderShellValue">1.5</span>
                    </div>
                    <div class="special-info">
                        âš¡ ç”µè·åªåˆ†å¸ƒåœ¨åœ†æŸ±å£³è¡¨é¢<br>
                        ğŸ“Š åœ†æŸ±å£³å†…éƒ¨ç”µåœºä¸ºé›¶ï¼Œé«˜æ–¯é¢åœ¨å†…éƒ¨æ—¶ç”µé€šé‡ä¸ºé›¶
                    </div>
                </div>

                <div class="control-group" id="planeControls" style="display:none;">
                    <div class="control-label">
                        <span class="charge-indicator" id="sigmaIndicator" style="background:#e74c3c"></span>
                        é¢ç”µè·å¯†åº¦ Ïƒ (Ã—10â»â¹ C/mÂ²)
                    </div>
                    <div class="slider-container">
                        <input type="range" id="sigmaSlider" class="positive-range" min="-2" max="2" step="0.1" value="1">
                        <span class="value-display">
                            <span id="sigmaValue" class="pos-value">+1.0</span>
                        </span>
                    </div>
                    <div class="control-label">å¹³é¢å°ºå¯¸ (m)</div>
                    <div class="slider-container">
                        <input type="range" id="planeSizeSlider" min="2" max="8" step="0.5" value="4">
                        <span class="value-display" id="planeSizeValue">4.0</span>
                    </div>
                </div>
            </div>

            <div class="data-panel">
                <h2 class="section-title">ğŸ“Š é«˜æ–¯å®šç†éªŒè¯</h2>
                <div id="fluxStatus" class="info" style="display:none;">
                    âš¡ é«˜æ–¯é¢ä½äºå¸¦ç”µä½“å†…éƒ¨ï¼Œä»å¤–éƒ¨è§†è§’å¯è§å†…éƒ¨é«˜æ–¯é¢
                </div>
                <div id="fieldInfo" class="info" style="display:none;">
                    ğŸ“Š å†…éƒ¨ç”µåœºçº¿å¯†åº¦éšåŠå¾„å˜åŒ–ï¼Œä½“ç°çœŸå®ç”µåœºåˆ†å¸ƒ
                </div>
                <div id="shellInfo" class="special-info" style="display:none;">
                    âš¡ å¸¦ç”µå£³å±‚ï¼šç”µè·åªåˆ†å¸ƒåœ¨è¡¨é¢ï¼Œå†…éƒ¨ç”µåœºä¸ºé›¶
                </div>
                <div class="data-row">
                    <span class="data-label">âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> :</span>
                    <span class="data-value" id="fluxValue">0</span>
                </div>
                <div class="data-row">
                    <span class="data-label">Q_enc / Îµâ‚€ :</span>
                    <span class="data-value" id="theoryValue">0</span>
                </div>
                <div id="gaussProofDisplay" class="gauss-proof">
                    å…¬å¼å°†åœ¨æ­¤æ˜¾ç¤º
                </div>
                <div id="fieldDistribution" class="info" style="display:none; margin-top:10px;">
                    çƒå†…: E âˆ rï¼Œçƒå¤–: E âˆ 1/rÂ²<br>
                    çƒå£³å†…: E = 0ï¼Œçƒå£³å¤–: E âˆ 1/rÂ²<br>
                    æŸ±å†…: E âˆ rï¼ŒæŸ±å¤–: E âˆ 1/r<br>
                    åœ†æŸ±å£³å†…: E = 0ï¼Œåœ†æŸ±å£³å¤–: E âˆ 1/r
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background:#e74c3c"></div>
                    <span>æ­£ç”µè·</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#3498db"></div>
                    <span>è´Ÿç”µè·</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#f1c40f"></div>
                    <span>æ­£ç”µåœºçº¿</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#9b59b6"></div>
                    <span>è´Ÿç”µåœºçº¿</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#ffffff"></div>
                    <span>è´Ÿç”µåœºçº¿ç®­å¤´</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#00ff00"></div>
                    <span>å¤–éƒ¨é«˜æ–¯é¢</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#ffff00"></div>
                    <span>å†…éƒ¨é«˜æ–¯é¢</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background:#ff6b6b"></div>
                    <span>å¸¦ç”µå£³å±‚è¡¨é¢</span>
                </div>
            </div>
        </div>

        <div id="visualization">
            <div id="canvas-container"></div>
            <div id="loading">æ­£åœ¨åˆå§‹åŒ–3Dåœºæ™¯...</div>
            <div id="instructions">ğŸ–±ï¸ é¼ æ ‡æ“ä½œï¼šå·¦é”®æ—‹è½¬ Â· å³é”®å¹³ç§» Â· æ»šè½®ç¼©æ”¾</div>
        </div>
    </div>

    <script>
        // ========== ç‰©ç†å¸¸é‡ ==========
        const EPSILON0 = 8.854187817e-12;

        // ========== å…¨å±€å˜é‡ ==========
        let scene, camera, renderer, controls;
        let chargeObject = null, gaussianSurface = null;
        let fieldLineTubes = [];
        let fieldLineArrows = []; // å­˜å‚¨ç”µåœºçº¿æ–¹å‘ç®­å¤´
        let currentChargeType = 'point';
        let showGaussian = true, showFieldLines = true;
        let params = {
            pointSphere: { Q: 1e-9, R: 1.0, gaussR: 2.0 },
            sphereShell: { Q: 1e-9, R: 1.0, gaussR: 2.0 },
            cylinder: { lambda: 1e-9, R: 0.5, gaussR: 1.5 },
            cylinderShell: { lambda: 1e-9, R: 0.5, gaussR: 1.5 },
            plane: { sigma: 1e-9, size: 4.0, gaussHeight: 2.0 }
        };

        // ========== è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°æ»‘å—é¢œè‰²å’Œæ˜¾ç¤º ==========
        function updateSliderStyle(sliderId, value, indicatorId) {
            const slider = document.getElementById(sliderId);
            const indicator = document.getElementById(indicatorId);
            
            if (Math.abs(value) < 0.05) { // æ¥è¿‘é›¶
                slider.className = 'zero-range';
                if(indicator) indicator.style.backgroundColor = '#95a5a6';
            } else if (value > 0) { // æ­£å€¼
                slider.className = 'positive-range';
                if(indicator) indicator.style.backgroundColor = '#e74c3c';
            } else { // è´Ÿå€¼
                slider.className = 'negative-range';
                if(indicator) indicator.style.backgroundColor = '#3498db';
            }
        }

        // ========== è¾…åŠ©å‡½æ•°ï¼šæ›´æ–°æ•°å€¼æ˜¾ç¤º ==========
        function updateValueDisplay(elementId, value, unit = '') {
            const element = document.getElementById(elementId);
            const absValue = Math.abs(value).toFixed(1);
            
            if (Math.abs(value) < 0.05) {
                element.textContent = `0.0${unit}`;
                element.className = 'zero-value';
            } else if (value > 0) {
                element.textContent = `+${absValue}${unit}`;
                element.className = 'pos-value';
            } else {
                element.textContent = `-${absValue}${unit}`;
                element.className = 'neg-value';
            }
        }

        // ========== ç‰©ç†è®¡ç®—å‡½æ•° ==========
        function calculateElectricField(position) {
            const x = position.x, y = position.y, z = position.z;
            let field = new THREE.Vector3(0, 0, 0);

            switch(currentChargeType) {
                case 'point':
                case 'sphere':
                    const r = position.length();
                    const Q = params.pointSphere.Q;
                    const R = params.pointSphere.R;
                    if (r === 0) return field;
                    if (currentChargeType === 'point' || r >= R) {
                        // çƒå¤–æˆ–ç‚¹ç”µè·ï¼šE = Q/(4Ï€Ïµâ‚€rÂ²)
                        const magnitude = Math.abs(Q) / (4 * Math.PI * EPSILON0 * r * r);
                        // æ–¹å‘ï¼šæ­£ç”µè·å‘å¤–ï¼Œè´Ÿç”µè·å‘å†…
                        const direction = (Q >= 0) ? 1 : -1;
                        field.copy(position).normalize().multiplyScalar(direction * magnitude);
                    } else {
                        // çƒå†…ï¼šE = (Qr)/(4Ï€Ïµâ‚€RÂ³) âˆ r
                        const magnitude = Math.abs(Q * r) / (4 * Math.PI * EPSILON0 * R * R * R);
                        const direction = (Q >= 0) ? 1 : -1;
                        field.copy(position).normalize().multiplyScalar(direction * magnitude);
                    }
                    break;

                case 'sphereShell':
                    const rShell = position.length();
                    const QShell = params.sphereShell.Q;
                    const RShell = params.sphereShell.R;
                    if (rShell === 0) return field;
                    if (rShell < RShell) {
                        // çƒå£³å†…éƒ¨ï¼šç”µåœºä¸ºé›¶
                        field.set(0, 0, 0);
                    } else {
                        // çƒå£³å¤–éƒ¨ï¼šE = Q/(4Ï€Ïµâ‚€rÂ²) ä¸ç‚¹ç”µè·ç›¸åŒ
                        const magnitude = Math.abs(QShell) / (4 * Math.PI * EPSILON0 * rShell * rShell);
                        const direction = (QShell >= 0) ? 1 : -1;
                        field.copy(position).normalize().multiplyScalar(direction * magnitude);
                    }
                    break;

                case 'cylinder':
                    const rho = Math.sqrt(x * x + z * z);
                    const lambda = params.cylinder.lambda;
                    const cylR = params.cylinder.R;
                    if (rho === 0) return field;
                    if (rho < cylR) {
                        // åœ†æŸ±ä½“å†…ï¼šE = (Î»r)/(2Ï€Ïµâ‚€RÂ²) âˆ r
                        const magnitude = Math.abs(lambda * rho) / (2 * Math.PI * EPSILON0 * cylR * cylR);
                        const direction = (lambda >= 0) ? 1 : -1;
                        field.set(x / rho, 0, z / rho).multiplyScalar(direction * magnitude);
                    } else {
                        // åœ†æŸ±ä½“å¤–ï¼šE = Î»/(2Ï€Ïµâ‚€Ï) âˆ 1/r
                        const magnitude = Math.abs(lambda) / (2 * Math.PI * EPSILON0 * rho);
                        const direction = (lambda >= 0) ? 1 : -1;
                        field.set(x / rho, 0, z / rho).multiplyScalar(direction * magnitude);
                    }
                    break;

                case 'cylinderShell':
                    const rhoShell = Math.sqrt(x * x + z * z);
                    const lambdaShell = params.cylinderShell.lambda;
                    const cylRShell = params.cylinderShell.R;
                    if (rhoShell === 0) return field;
                    if (rhoShell < cylRShell) {
                        // åœ†æŸ±å£³å†…éƒ¨ï¼šç”µåœºä¸ºé›¶
                        field.set(0, 0, 0);
                    } else {
                        // åœ†æŸ±å£³å¤–éƒ¨ï¼šE = Î»/(2Ï€Ïµâ‚€Ï) âˆ 1/r
                        const magnitude = Math.abs(lambdaShell) / (2 * Math.PI * EPSILON0 * rhoShell);
                        const direction = (lambdaShell >= 0) ? 1 : -1;
                        field.set(x / rhoShell, 0, z / rhoShell).multiplyScalar(direction * magnitude);
                    }
                    break;

                case 'plane':
                    const sigma = params.plane.sigma;
                    const magnitude = Math.abs(sigma) / (2 * EPSILON0);
                    // æ­£ç”µè·ï¼šå¹³é¢ä¸Šæ–¹å‘å¤–ï¼Œå¹³é¢ä¸‹æ–¹å‘å†…
                    // è´Ÿç”µè·ï¼šå¹³é¢ä¸Šæ–¹å‘å†…ï¼Œå¹³é¢ä¸‹æ–¹å‘å¤–
                    const direction = (sigma >= 0) ? 1 : -1;
                    const fieldY = (y >= 0) ? direction * magnitude : -direction * magnitude;
                    field.set(0, fieldY, 0);
                    break;
            }
            return field;
        }

        // ========== 3Dåœºæ™¯åˆå§‹åŒ– ==========
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(6, 4, 6);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 15, 10);
            scene.add(directionalLight);

            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            document.getElementById('loading').style.display = 'none';
            updateChargeObject();
            updateFieldLines();
            updateGaussianSurface();
            animate();
        }

        // ========== 3Då¯¹è±¡åˆ›å»º ==========
        function updateChargeObject() {
            if (chargeObject) scene.remove(chargeObject);

            let chargeValue = 0;
            let objectColor = 0xFFFFFF;
            
            // ç¡®å®šç”µè·å€¼å’Œé¢œè‰²
            switch(currentChargeType) {
                case 'point':
                case 'sphere':
                    chargeValue = params.pointSphere.Q;
                    objectColor = (chargeValue >= 0) ? 0xe74c3c : 0x3498db; // çº¢è‰²æ­£ç”µè·ï¼Œè“è‰²è´Ÿç”µè·
                    break;
                case 'sphereShell':
                    chargeValue = params.sphereShell.Q;
                    objectColor = (chargeValue >= 0) ? 0xe74c3c : 0x3498db; // çº¢è‰²æ­£ç”µè·ï¼Œè“è‰²è´Ÿç”µè·
                    break;
                case 'cylinder':
                    chargeValue = params.cylinder.lambda;
                    objectColor = (chargeValue >= 0) ? 0xe67e22 : 0x3498db; // æ©™è‰²æ­£ç”µè·ï¼Œè“è‰²è´Ÿç”µè·
                    break;
                case 'cylinderShell':
                    chargeValue = params.cylinderShell.lambda;
                    objectColor = (chargeValue >= 0) ? 0xe67e22 : 0x3498db; // æ©™è‰²æ­£ç”µè·ï¼Œè“è‰²è´Ÿç”µè·
                    break;
                case 'plane':
                    chargeValue = params.plane.sigma;
                    objectColor = (chargeValue >= 0) ? 0x9b59b6 : 0x3498db; // ç´«è‰²æ­£ç”µè·ï¼Œè“è‰²è´Ÿç”µè·
                    break;
            }

            // åˆ›å»ºå¸¦ç”µä½“ - å¯¹äºå£³å±‚ä½¿ç”¨ä¸åŒçš„æ˜¾ç¤ºæ–¹å¼
            switch(currentChargeType) {
                case 'point':
                    const pointGeometry = new THREE.SphereGeometry(0.2, 16, 16);
                    const pointMaterial = new THREE.MeshPhongMaterial({
                        color: objectColor,
                        emissive: objectColor,
                        emissiveIntensity: 0.3,
                        shininess: 100
                    });
                    chargeObject = new THREE.Mesh(pointGeometry, pointMaterial);
                    break;
                case 'sphere':
                    const sphereGeometry = new THREE.SphereGeometry(params.pointSphere.R, 32, 32);
                    const sphereMaterial = new THREE.MeshPhongMaterial({
                        color: objectColor,
                        transparent: true,
                        opacity: 0.6, // é™ä½é€æ˜åº¦ï¼Œè®©å†…éƒ¨é«˜æ–¯é¢æ›´å¯è§
                        side: THREE.DoubleSide // åŒé¢æ¸²æŸ“
                    });
                    chargeObject = new THREE.Mesh(sphereGeometry, sphereMaterial);
                    break;
                case 'sphereShell':
                    // çƒå£³ï¼šç”¨çº¿æ¡†çƒä½“è¡¨ç¤ºï¼Œå†…éƒ¨æ˜¯ç©ºçš„
                    const sphereShellGeometry = new THREE.SphereGeometry(params.sphereShell.R, 32, 32);
                    const sphereShellMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff6b6b, // å£³å±‚ä½¿ç”¨ç‰¹æ®Šé¢œè‰²
                        wireframe: true,
                        transparent: true,
                        opacity: 0.8,
                        side: THREE.DoubleSide
                    });
                    chargeObject = new THREE.Mesh(sphereShellGeometry, sphereShellMaterial);
                    break;
                case 'cylinder':
                    const cylinderGeometry = new THREE.CylinderGeometry(
                        params.cylinder.R, params.cylinder.R, 8, 32
                    );
                    const cylinderMaterial = new THREE.MeshPhongMaterial({
                        color: objectColor,
                        transparent: true,
                        opacity: 0.6, // é™ä½é€æ˜åº¦ï¼Œè®©å†…éƒ¨é«˜æ–¯é¢æ›´å¯è§
                        side: THREE.DoubleSide // åŒé¢æ¸²æŸ“
                    });
                    chargeObject = new THREE.Mesh(cylinderGeometry, cylinderMaterial);
                    break;
                case 'cylinderShell':
                    // åœ†æŸ±å£³ï¼šç”¨çº¿æ¡†åœ†æŸ±ä½“è¡¨ç¤ºï¼Œå†…éƒ¨æ˜¯ç©ºçš„
                    const cylinderShellGeometry = new THREE.CylinderGeometry(
                        params.cylinderShell.R, params.cylinderShell.R, 8, 32
                    );
                    const cylinderShellMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff6b6b, // å£³å±‚ä½¿ç”¨ç‰¹æ®Šé¢œè‰²
                        wireframe: true,
                        transparent: true,
                        opacity: 0.8,
                        side: THREE.DoubleSide
                    });
                    chargeObject = new THREE.Mesh(cylinderShellGeometry, cylinderShellMaterial);
                    break;
                case 'plane':
                    const planeGeometry = new THREE.PlaneGeometry(params.plane.size, params.plane.size);
                    const planeMaterial = new THREE.MeshPhongMaterial({
                        color: objectColor,
                        transparent: true,
                        opacity: 0.6,
                        side: THREE.DoubleSide
                    });
                    chargeObject = new THREE.Mesh(planeGeometry, planeMaterial);
                    chargeObject.rotation.x = Math.PI / 2;
                    break;
            }
            
            if (chargeObject) {
                chargeObject.castShadow = true;
                scene.add(chargeObject);
            }
            updatePhysicsData();
        }

        // ========== ç”µåœºçº¿ç³»ç»Ÿ ==========
        function updateFieldLines() {
            // æ¸…é™¤æ—§çš„ç”µåœºçº¿å’Œç®­å¤´
            fieldLineTubes.forEach(tube => scene.remove(tube));
            fieldLineTubes = [];
            fieldLineArrows.forEach(arrow => scene.remove(arrow));
            fieldLineArrows = [];
            
            if (!showFieldLines) return;

            // æ£€æŸ¥ç”µè·æ˜¯å¦æ¥è¿‘é›¶
            let chargeNearZero = false;
            switch(currentChargeType) {
                case 'point':
                case 'sphere':
                    chargeNearZero = Math.abs(params.pointSphere.Q) < 0.05e-9;
                    break;
                case 'sphereShell':
                    chargeNearZero = Math.abs(params.sphereShell.Q) < 0.05e-9;
                    break;
                case 'cylinder':
                    chargeNearZero = Math.abs(params.cylinder.lambda) < 0.05e-9;
                    break;
                case 'cylinderShell':
                    chargeNearZero = Math.abs(params.cylinderShell.lambda) < 0.05e-9;
                    break;
                case 'plane':
                    chargeNearZero = Math.abs(params.plane.sigma) < 0.05e-9;
                    break;
            }
            
            if (chargeNearZero) return;

            let lines = [];
            switch(currentChargeType) {
                case 'point':
                    const qFactor = Math.abs(params.pointSphere.Q / 1e-9);
                    const totalLinesPoint = Math.max(12, Math.round(20 * qFactor));
                    lines = generatePointChargeFieldLines(totalLinesPoint, 4);
                    break;
                case 'sphere':
                    const qFactorSphere = Math.abs(params.pointSphere.Q / 1e-9);
                    const totalLinesSphere = Math.max(16, Math.round(24 * qFactorSphere));
                    lines = generateSphereFieldLinesWithDensity(totalLinesSphere, 4);
                    break;
                case 'sphereShell':
                    const qFactorShell = Math.abs(params.sphereShell.Q / 1e-9);
                    const totalLinesShell = Math.max(16, Math.round(24 * qFactorShell));
                    // çƒå£³ï¼šåªåœ¨å¤–éƒ¨ç”Ÿæˆç”µåœºçº¿
                    lines = generateSphereShellFieldLines(totalLinesShell, 4);
                    break;
                case 'cylinder':
                    const lambdaFactor = Math.abs(params.cylinder.lambda / 1e-9);
                    const totalLinesCylinder = Math.max(8, Math.round(12 * lambdaFactor));
                    lines = generateCylinderFieldLinesWithDensity(totalLinesCylinder, 3);
                    break;
                case 'cylinderShell':
                    const lambdaShellFactor = Math.abs(params.cylinderShell.lambda / 1e-9);
                    const totalLinesCylinderShell = Math.max(8, Math.round(12 * lambdaShellFactor));
                    // åœ†æŸ±å£³ï¼šåªåœ¨å¤–éƒ¨ç”Ÿæˆç”µåœºçº¿
                    lines = generateCylinderShellFieldLines(totalLinesCylinderShell, 3);
                    break;
                case 'plane':
                    const sigmaFactor = Math.abs(params.plane.sigma / 1e-9);
                    const baseSpacing = 1.0;
                    const lineSpacing = baseSpacing / Math.sqrt(sigmaFactor);
                    lines = generatePlanarFieldLinesBySpacing(lineSpacing, 3);
                    break;
            }

            // æ ¹æ®ç”µè·å€¼ç¡®å®šåŸºç¡€é¢œè‰²
            const baseColor = (getCurrentChargeValue() >= 0) ? 0xf1c40f : 0x9b59b6;
            
            lines.forEach((points, index) => {
                // æ ¹æ®ç”µåœºå¼ºåº¦è°ƒæ•´é¢œè‰²é¥±å’Œåº¦ï¼Œä½“ç°ç”µåœºå¼ºåº¦å˜åŒ–
                const avgR = points.length > 0 ? 
                    points.reduce((sum, p) => sum + p.length(), 0) / points.length : 0;
                let intensity = 1.0;
                
                if (currentChargeType === 'sphere' && params.pointSphere.R > 0) {
                    // çƒä½“ï¼šå†…éƒ¨ç”µåœºå¼ºåº¦éšrå¢åŠ ï¼Œå¤–éƒ¨éšrÂ²å‡å°
                    if (avgR < params.pointSphere.R) {
                        // å†…éƒ¨ï¼šé¢œè‰²å˜æµ…è¡¨ç¤ºç”µåœºè¾ƒå¼±
                        intensity = 0.6 + 0.4 * (avgR / params.pointSphere.R);
                    } else {
                        // å¤–éƒ¨ï¼šé¢œè‰²å˜æ·±è¡¨ç¤ºç”µåœºè¾ƒå¼º
                        intensity = 1.0 - 0.3 * (avgR - params.pointSphere.R) / (4 - params.pointSphere.R);
                    }
                } else if (currentChargeType === 'sphereShell' && params.sphereShell.R > 0) {
                    // çƒå£³ï¼šå†…éƒ¨æ²¡æœ‰ç”µåœºçº¿ï¼Œå¤–éƒ¨ä¸çƒä½“ç±»ä¼¼
                    if (avgR < params.sphereShell.R) {
                        // å†…éƒ¨ä¸åº”è¯¥æœ‰ç”µåœºçº¿ï¼Œä½†ä»¥é˜²ä¸‡ä¸€
                        intensity = 0.3;
                    } else {
                        intensity = 1.0 - 0.3 * (avgR - params.sphereShell.R) / (4 - params.sphereShell.R);
                    }
                } else if (currentChargeType === 'cylinder' && params.cylinder.R > 0) {
                    // åœ†æŸ±ä½“ï¼šå†…éƒ¨ç”µåœºå¼ºåº¦éšrå¢åŠ ï¼Œå¤–éƒ¨éšrå‡å°
                    const avgRho = points.length > 0 ? 
                        Math.sqrt(points[0].x * points[0].x + points[0].z * points[0].z) : 0;
                    if (avgRho < params.cylinder.R) {
                        intensity = 0.6 + 0.4 * (avgRho / params.cylinder.R);
                    } else {
                        intensity = 1.0 - 0.3 * (avgRho - params.cylinder.R) / (3 - params.cylinder.R);
                    }
                } else if (currentChargeType === 'cylinderShell' && params.cylinderShell.R > 0) {
                    // åœ†æŸ±å£³ï¼šå†…éƒ¨æ²¡æœ‰ç”µåœºçº¿ï¼Œå¤–éƒ¨ä¸åœ†æŸ±ä½“ç±»ä¼¼
                    const avgRho = points.length > 0 ? 
                        Math.sqrt(points[0].x * points[0].x + points[0].z * points[0].z) : 0;
                    if (avgRho < params.cylinderShell.R) {
                        // å†…éƒ¨ä¸åº”è¯¥æœ‰ç”µåœºçº¿ï¼Œä½†ä»¥é˜²ä¸‡ä¸€
                        intensity = 0.3;
                    } else {
                        intensity = 1.0 - 0.3 * (avgRho - params.cylinderShell.R) / (3 - params.cylinderShell.R);
                    }
                }
                
                // åˆ›å»ºç”µåœºçº¿ç®¡
                const tube = createFieldLineTube(points, baseColor, intensity);
                scene.add(tube);
                fieldLineTubes.push(tube);
                
                // åœ¨ç”µåœºçº¿æœ«ç«¯æ·»åŠ æ–¹å‘ç®­å¤´
                if (points.length >= 2) {
                    const lastPoint = points[points.length - 1];
                    const secondLastPoint = points[points.length - 2];
                    
                    // è®¡ç®—æ–¹å‘
                    const direction = new THREE.Vector3()
                        .subVectors(lastPoint, secondLastPoint)
                        .normalize();
                    
                    // æ ¹æ®ç”µè·æ­£è´Ÿè°ƒæ•´ç®­å¤´æ–¹å‘
                    const chargeValue = getCurrentChargeValue();
                    if (chargeValue < 0) {
                        direction.multiplyScalar(-1);
                    }
                    
                    // ä¼˜åŒ–ï¼šè´Ÿç”µè·ä½¿ç”¨ç™½è‰²ç®­å¤´ï¼Œæ­£ç”µè·ä½¿ç”¨ä¸ç”µåœºçº¿ç›¸åŒçš„é¢œè‰²
                    const arrowColor = (chargeValue >= 0) ? 0xf1c40f : 0xffffff;
                    const arrow = createDirectionArrow(lastPoint, direction, arrowColor);
                    scene.add(arrow);
                    fieldLineArrows.push(arrow);
                }
            });
        }
        
        // è·å–å½“å‰ç”µè·å€¼
        function getCurrentChargeValue() {
            switch(currentChargeType) {
                case 'point':
                case 'sphere': return params.pointSphere.Q;
                case 'sphereShell': return params.sphereShell.Q;
                case 'cylinder': return params.cylinder.lambda;
                case 'cylinderShell': return params.cylinderShell.lambda;
                case 'plane': return params.plane.sigma;
                default: return 0;
            }
        }

        // ç‚¹ç”µè·ç”µåœºçº¿ç”Ÿæˆ
        function generatePointChargeFieldLines(numLines, maxR) {
            const lines = [];
            const startR = 0.1;
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));

            for (let i = 0; i < numLines; i++) {
                const y = 1 - (i / (numLines - 1)) * 2;
                const radius = Math.sqrt(1 - y * y);
                const theta = goldenAngle * i;
                const x = Math.cos(theta) * radius;
                const z = Math.sin(theta) * radius;

                const direction = new THREE.Vector3(x, y, z).normalize();
                const points = [];
                // ç”Ÿæˆä»å†…åˆ°å¤–çš„ç”µåœºçº¿ï¼Œé—´è·é€æ¸å¢å¤§ï¼ˆç”µåœºå¼ºåº¦å‡å°ï¼‰
                for (let r = startR; r <= maxR; r += 0.05 * Math.sqrt(r)) {
                    points.push(direction.clone().multiplyScalar(r));
                }
                if (points.length > 1) lines.push(points);
            }
            return lines;
        }

        // çƒä½“ç”µåœºçº¿ç”Ÿæˆï¼ˆè€ƒè™‘å†…éƒ¨ç”µåœºå¯†åº¦ï¼‰
        function generateSphereFieldLinesWithDensity(numLines, maxR) {
            const lines = [];
            const R = params.pointSphere.R;
            const startR = 0.05; // ä»é è¿‘ä¸­å¿ƒå¼€å§‹
            
            // å†…éƒ¨å’Œå¤–éƒ¨ç”µåœºçº¿å¯†åº¦ä¸åŒ
            const innerLines = Math.floor(numLines * 0.3); // 30%çš„ç”µåœºçº¿ä»å†…éƒ¨å¼€å§‹
            const outerLines = numLines - innerLines; // 70%çš„ç”µåœºçº¿ä»è¡¨é¢å¼€å§‹
            
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));

            // ç”Ÿæˆå†…éƒ¨ç”µåœºçº¿ï¼ˆä»ä¸­å¿ƒé™„è¿‘å¼€å§‹ï¼‰
            for (let i = 0; i < innerLines; i++) {
                const y = 1 - (i / (innerLines - 1)) * 2;
                const radius = Math.sqrt(1 - y * y);
                const theta = goldenAngle * i;
                const x = Math.cos(theta) * radius;
                const z = Math.sin(theta) * radius;

                const direction = new THREE.Vector3(x, y, z).normalize();
                const points = [];
                
                // å†…éƒ¨ç”µåœºçº¿ï¼šä»ä¸­å¿ƒåˆ°è¡¨é¢å†åˆ°å¤–éƒ¨
                for (let r = startR; r <= maxR; r += 0.05) {
                    if (r < R) {
                        // å†…éƒ¨ï¼šé—´è·è¾ƒå°ï¼Œä½“ç°ç”µåœºçº¿å¯†åº¦
                        points.push(direction.clone().multiplyScalar(r));
                    } else {
                        // å¤–éƒ¨ï¼šé—´è·é€æ¸å¢å¤§
                        points.push(direction.clone().multiplyScalar(r));
                    }
                }
                if (points.length > 1) lines.push(points);
            }

            // ç”Ÿæˆå¤–éƒ¨ç”µåœºçº¿ï¼ˆä»è¡¨é¢å¼€å§‹ï¼‰
            for (let i = 0; i < outerLines; i++) {
                const y = 1 - (i / (outerLines - 1)) * 2;
                const radius = Math.sqrt(1 - y * y);
                const theta = goldenAngle * (i + innerLines);
                const x = Math.cos(theta) * radius;
                const z = Math.sin(theta) * radius;

                const direction = new THREE.Vector3(x, y, z).normalize();
                const points = [];
                
                // ä»è¡¨é¢å¼€å§‹å‘å¤–
                for (let r = R; r <= maxR; r += 0.1 * Math.sqrt(r/R)) {
                    points.push(direction.clone().multiplyScalar(r));
                }
                if (points.length > 1) lines.push(points);
            }

            return lines;
        }

        // çƒå£³ç”µåœºçº¿ç”Ÿæˆï¼ˆåªåœ¨å¤–éƒ¨ç”Ÿæˆç”µåœºçº¿ï¼‰
        function generateSphereShellFieldLines(numLines, maxR) {
            const lines = [];
            const R = params.sphereShell.R;
            const goldenAngle = Math.PI * (3 - Math.sqrt(5));

            for (let i = 0; i < numLines; i++) {
                const y = 1 - (i / (numLines - 1)) * 2;
                const radius = Math.sqrt(1 - y * y);
                const theta = goldenAngle * i;
                const x = Math.cos(theta) * radius;
                const z = Math.sin(theta) * radius;

                const direction = new THREE.Vector3(x, y, z).normalize();
                const points = [];
                
                // çƒå£³ï¼šåªä»è¡¨é¢å¼€å§‹å‘å¤–ç”Ÿæˆç”µåœºçº¿
                for (let r = R; r <= maxR; r += 0.1 * Math.sqrt(r/R)) {
                    points.push(direction.clone().multiplyScalar(r));
                }
                if (points.length > 1) lines.push(points);
            }

            return lines;
        }

        // åœ†æŸ±ä½“ç”µåœºçº¿ç”Ÿæˆï¼ˆè€ƒè™‘å†…éƒ¨ç”µåœºå¯†åº¦ï¼‰
        function generateCylinderFieldLinesWithDensity(numLines, maxRho) {
            const lines = [];
            const R = params.cylinder.R;
            const startRho = 0.05; // ä»é è¿‘è½´çº¿å¼€å§‹
            
            // å†…éƒ¨å’Œå¤–éƒ¨ç”µåœºçº¿å¯†åº¦ä¸åŒ
            const innerLines = Math.floor(numLines * 0.4); // 40%çš„ç”µåœºçº¿ä»å†…éƒ¨å¼€å§‹
            const outerLines = numLines - innerLines; // 60%çš„ç”µåœºçº¿ä»è¡¨é¢å¼€å§‹

            // ç”Ÿæˆå†…éƒ¨ç”µåœºçº¿ï¼ˆä»è½´çº¿é™„è¿‘å¼€å§‹ï¼‰
            for (let i = 0; i < innerLines; i++) {
                const phi = (i / innerLines) * 2 * Math.PI;
                for (let y of [-2, 0, 2]) {
                    const points = [];
                    // ä»é è¿‘è½´çº¿å¼€å§‹åˆ°è¡¨é¢å†åˆ°å¤–éƒ¨
                    for (let rho = startRho; rho <= maxRho; rho += 0.05) {
                        if (rho < R) {
                            // å†…éƒ¨ï¼šé—´è·è¾ƒå°
                            points.push(new THREE.Vector3(rho * Math.cos(phi), y, rho * Math.sin(phi)));
                        } else {
                            // å¤–éƒ¨ï¼šé—´è·é€æ¸å¢å¤§
                            points.push(new THREE.Vector3(rho * Math.cos(phi), y, rho * Math.sin(phi)));
                        }
                    }
                    if (points.length > 1) lines.push(points);
                }
            }

            // ç”Ÿæˆå¤–éƒ¨ç”µåœºçº¿ï¼ˆä»è¡¨é¢å¼€å§‹ï¼‰
            for (let i = 0; i < outerLines; i++) {
                const phi = (i / outerLines) * 2 * Math.PI;
                for (let y of [-2, 0, 2]) {
                    const points = [];
                    // ä»è¡¨é¢å¼€å§‹å‘å¤–
                    for (let rho = R; rho <= maxRho; rho += 0.08 * Math.sqrt(rho/R)) {
                        points.push(new THREE.Vector3(rho * Math.cos(phi), y, rho * Math.sin(phi)));
                    }
                    if (points.length > 1) lines.push(points);
                }
            }

            return lines;
        }

        // åœ†æŸ±å£³ç”µåœºçº¿ç”Ÿæˆï¼ˆåªåœ¨å¤–éƒ¨ç”Ÿæˆç”µåœºçº¿ï¼‰
        function generateCylinderShellFieldLines(numLines, maxRho) {
            const lines = [];
            const R = params.cylinderShell.R;

            for (let i = 0; i < numLines; i++) {
                const phi = (i / numLines) * 2 * Math.PI;
                for (let y of [-2, 0, 2]) {
                    const points = [];
                    // ä»è¡¨é¢å¼€å§‹å‘å¤–
                    for (let rho = R; rho <= maxRho; rho += 0.08 * Math.sqrt(rho/R)) {
                        points.push(new THREE.Vector3(rho * Math.cos(phi), y, rho * Math.sin(phi)));
                    }
                    if (points.length > 1) lines.push(points);
                }
            }

            return lines;
        }

        function generatePlanarFieldLinesBySpacing(lineSpacing, length) {
            const lines = [];
            const halfSize = params.plane.size / 2;
            const startX = -halfSize + lineSpacing / 2;
            const startZ = -halfSize + lineSpacing / 2;

            for (let x = startX; x <= halfSize; x += lineSpacing) {
                for (let z = startZ; z <= halfSize; z += lineSpacing) {
                    lines.push([new THREE.Vector3(x, 0.1, z), new THREE.Vector3(x, length, z)]);
                    lines.push([new THREE.Vector3(x, -0.1, z), new THREE.Vector3(x, -length, z)]);
                }
            }
            return lines;
        }

        // ä¿®æ”¹ï¼šæ·»åŠ å¼ºåº¦å‚æ•°è°ƒæ•´ç”µåœºçº¿é¢œè‰²
        function createFieldLineTube(points, color, intensity = 1.0) {
            const curve = new THREE.CatmullRomCurve3(points);
            const tubeGeometry = new THREE.TubeGeometry(curve, points.length * 5, 0.03, 8, false);
            
            // æ ¹æ®å¼ºåº¦è°ƒæ•´é¢œè‰²
            const hsl = new THREE.Color(color).getHSL({});
            const adjustedColor = new THREE.Color().setHSL(hsl.h, hsl.s * intensity, hsl.l * (0.7 + 0.3 * intensity));
            
            const tubeMaterial = new THREE.MeshPhongMaterial({
                color: adjustedColor,
                emissive: adjustedColor,
                emissiveIntensity: 0.2 * intensity,
                transparent: true,
                opacity: 0.8 * intensity
            });
            return new THREE.Mesh(tubeGeometry, tubeMaterial);
        }
        
        // åˆ›å»ºæ–¹å‘ç®­å¤´
        function createDirectionArrow(position, direction, color) {
            const arrowLength = (color === 0xffffff) ? 0.45 : 0.4;
            const arrowHeadLength = (color === 0xffffff) ? 0.25 : 0.2;
            const arrowHeadWidth = (color === 0xffffff) ? 0.15 : 0.12;
            
            const arrowHelper = new THREE.ArrowHelper(
                direction,
                position,
                arrowLength,
                color,
                arrowHeadLength,
                arrowHeadWidth
            );
            
            // ä¸ºç®­å¤´æ·»åŠ å‘å…‰æ•ˆæœ
            if (arrowHelper.line && arrowHelper.cone) {
                const glowIntensity = (color === 0xffffff) ? 1.0 : 0.8;
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: glowIntensity
                });
                arrowHelper.cone.material = glowMaterial;
                arrowHelper.line.material = glowMaterial;
            }
            
            return arrowHelper;
        }

        // ========== é«˜æ–¯é¢ç³»ç»Ÿï¼ˆå…³é”®ä¿®æ”¹ï¼šç¡®ä¿å†…éƒ¨é«˜æ–¯é¢ä»å¤–éƒ¨å¯è§ï¼‰==========
        function updateGaussianSurface() {
            // æ¸…é™¤æ—§çš„é«˜æ–¯é¢
            if (gaussianSurface) {
                scene.remove(gaussianSurface);
                gaussianSurface = null;
            }
            
            if (!showGaussian) return;

            // æ£€æŸ¥é«˜æ–¯é¢æ˜¯å¦åœ¨å¸¦ç”µä½“å†…éƒ¨
            const isInside = checkIfGaussianInside();
            
            // å…³é”®ä¿®æ”¹ï¼šæ— è®ºé«˜æ–¯é¢åœ¨å†…éƒ¨è¿˜æ˜¯å¤–éƒ¨ï¼Œéƒ½åˆ›å»ºé«˜æ–¯é¢
            // ä½¿ç”¨æ›´é†’ç›®çš„é¢œè‰²å’Œçº¿å®½ï¼Œç¡®ä¿å¯è§æ€§
            const gaussColor = isInside ? 0xffff00 : 0x00ff00; // å†…éƒ¨é»„è‰²ï¼Œå¤–éƒ¨ç»¿è‰²
            const baseOpacity = isInside ? 0.9 : 0.7; // å†…éƒ¨æ›´ä¸é€æ˜
            const lineWidth = isInside ? 4 : 2; // å†…éƒ¨çº¿å®½æ›´ç²—

            switch(currentChargeType) {
                case 'point':
                case 'sphere':
                case 'sphereShell':
                    const gaussR = currentChargeType === 'sphereShell' ? 
                        params.sphereShell.gaussR : params.pointSphere.gaussR;
                    const sphereGaussGeometry = new THREE.SphereGeometry(gaussR, 32, 32);
                    const sphereGaussMaterial = new THREE.MeshBasicMaterial({
                        color: gaussColor,
                        wireframe: true,
                        transparent: true,
                        opacity: baseOpacity,
                        wireframeLinewidth: lineWidth,
                        depthTest: false // ç¦ç”¨æ·±åº¦æµ‹è¯•ï¼Œç¡®ä¿å§‹ç»ˆå¯è§
                    });
                    gaussianSurface = new THREE.Mesh(sphereGaussGeometry, sphereGaussMaterial);
                    break;
                case 'cylinder':
                case 'cylinderShell':
                    const gaussRho = currentChargeType === 'cylinderShell' ? 
                        params.cylinderShell.gaussR : params.cylinder.gaussR;
                    const cylinderGaussGeometry = new THREE.CylinderGeometry(
                        gaussRho, gaussRho, 8, 32, 1, true
                    );
                    const cylinderGaussMaterial = new THREE.MeshBasicMaterial({
                        color: gaussColor,
                        wireframe: true,
                        transparent: true,
                        opacity: baseOpacity,
                        side: THREE.DoubleSide,
                        wireframeLinewidth: lineWidth,
                        depthTest: false // ç¦ç”¨æ·±åº¦æµ‹è¯•ï¼Œç¡®ä¿å§‹ç»ˆå¯è§
                    });
                    gaussianSurface = new THREE.Mesh(cylinderGaussGeometry, cylinderGaussMaterial);
                    break;
                case 'plane':
                    const planeGaussRadius = Math.min(params.plane.size / 3, 2.5);
                    const planeGaussGeometry = new THREE.CylinderGeometry(
                        planeGaussRadius, planeGaussRadius, params.plane.gaussHeight, 32, 1, false
                    );
                    const planeGaussMaterial = new THREE.MeshBasicMaterial({
                        color: gaussColor,
                        wireframe: true,
                        transparent: true,
                        opacity: baseOpacity,
                        side: THREE.DoubleSide,
                        wireframeLinewidth: lineWidth,
                        depthTest: false // ç¦ç”¨æ·±åº¦æµ‹è¯•ï¼Œç¡®ä¿å§‹ç»ˆå¯è§
                    });
                    gaussianSurface = new THREE.Mesh(planeGaussGeometry, planeGaussMaterial);
                    break;
            }
            
            if (gaussianSurface) {
                // è®¾ç½®renderOrderä¸ºæœ€é«˜ï¼Œç¡®ä¿é«˜æ–¯é¢åœ¨æœ€åæ¸²æŸ“ï¼ˆåœ¨æœ€å‰é¢ï¼‰
                gaussianSurface.renderOrder = 1000;
                scene.add(gaussianSurface);
            }
        }

        // æ£€æŸ¥é«˜æ–¯é¢æ˜¯å¦åœ¨å¸¦ç”µä½“å†…éƒ¨
        function checkIfGaussianInside() {
            switch(currentChargeType) {
                case 'point':
                    return params.pointSphere.gaussR < 0.3; // ç‚¹ç”µè·è¿‘ä¼¼åŠå¾„
                case 'sphere':
                    return params.pointSphere.gaussR < params.pointSphere.R;
                case 'sphereShell':
                    return params.sphereShell.gaussR < params.sphereShell.R;
                case 'cylinder':
                    return params.cylinder.gaussR < params.cylinder.R;
                case 'cylinderShell':
                    return params.cylinderShell.gaussR < params.cylinderShell.R;
                case 'plane':
                    // å¹³é¢æ²¡æœ‰å†…éƒ¨çš„æ¦‚å¿µï¼Œå§‹ç»ˆè¿”å›false
                    return false;
                default:
                    return false;
            }
        }

        // ========== ç‰©ç†æ•°æ®ä¸é«˜æ–¯å®šç†éªŒè¯ ==========
        function updatePhysicsData() {
            let flux = 0, enclosedCharge = 0, theoryValue = 0;
            let formulaText = '';
            const isInside = checkIfGaussianInside();
            
            // æ˜¾ç¤º/éšè—å†…éƒ¨è­¦å‘Šå’Œä¿¡æ¯
            const fluxStatus = document.getElementById('fluxStatus');
            const fieldInfo = document.getElementById('fieldInfo');
            const shellInfo = document.getElementById('shellInfo');
            const fieldDistribution = document.getElementById('fieldDistribution');
            
            // æ˜¾ç¤ºå¸¦ç”µå£³å±‚çš„ç‰¹æ®Šä¿¡æ¯
            if (currentChargeType === 'sphereShell' || currentChargeType === 'cylinderShell') {
                shellInfo.style.display = 'block';
                fieldDistribution.style.display = 'block';
                fieldInfo.style.display = 'none';
            } else if (currentChargeType === 'sphere' || currentChargeType === 'cylinder') {
                fieldInfo.style.display = 'block';
                fieldDistribution.style.display = 'block';
                shellInfo.style.display = 'none';
            } else {
                fieldInfo.style.display = 'none';
                fieldDistribution.style.display = 'none';
                shellInfo.style.display = 'none';
            }
            
            if (isInside && currentChargeType !== 'plane') {
                fluxStatus.style.display = 'block';
                let gaussR = 0, R = 0;
                switch(currentChargeType) {
                    case 'point':
                        gaussR = params.pointSphere.gaussR;
                        R = 0.3; break;
                    case 'sphere':
                        gaussR = params.pointSphere.gaussR;
                        R = params.pointSphere.R; break;
                    case 'sphereShell':
                        gaussR = params.sphereShell.gaussR;
                        R = params.sphereShell.R; break;
                    case 'cylinder':
                        gaussR = params.cylinder.gaussR;
                        R = params.cylinder.R; break;
                    case 'cylinderShell':
                        gaussR = params.cylinderShell.gaussR;
                        R = params.cylinderShell.R; break;
                }
                fluxStatus.innerHTML = `âš¡ é«˜æ–¯é¢ä½äºå¸¦ç”µä½“å†…éƒ¨<br>
                ğŸ“ é«˜æ–¯é¢åŠå¾„: ${gaussR.toFixed(2)} m<br>
                ğŸ“ å¸¦ç”µä½“åŠå¾„: ${R.toFixed(2)} m`;
            } else {
                fluxStatus.style.display = 'none';
            }

            switch(currentChargeType) {
                case 'point':
                    enclosedCharge = params.pointSphere.Q;
                    theoryValue = enclosedCharge / EPSILON0;
                    flux = theoryValue;
                    if (isInside) {
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = Q/Îµâ‚€ = ${flux.toExponential(3)} NÂ·mÂ²/C (ç‚¹ç”µè·å†…éƒ¨)`;
                    } else {
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = Q/Îµâ‚€ = ${flux.toExponential(3)} NÂ·mÂ²/C`;
                    }
                    break;
                case 'sphere':
                    const Q = params.pointSphere.Q;
                    const gaussR = params.pointSphere.gaussR;
                    if (gaussR >= params.pointSphere.R) {
                        enclosedCharge = Q;
                        theoryValue = enclosedCharge / EPSILON0;
                        flux = theoryValue;
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = Q/Îµâ‚€ = ${flux.toExponential(3)} NÂ·mÂ²/C (çƒå¤–)`;
                    } else {
                        enclosedCharge = Q * Math.pow(gaussR / params.pointSphere.R, 3);
                        theoryValue = enclosedCharge / EPSILON0;
                        flux = theoryValue;
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = Q_enc/Îµâ‚€ = (QÂ·rÂ³/RÂ³)/Îµâ‚€ = ${flux.toExponential(3)} NÂ·mÂ²/C (çƒå†…)`;
                    }
                    break;
                case 'sphereShell':
                    const QShell = params.sphereShell.Q;
                    const gaussRShell = params.sphereShell.gaussR;
                    if (gaussRShell >= params.sphereShell.R) {
                        enclosedCharge = QShell;
                        theoryValue = enclosedCharge / EPSILON0;
                        flux = theoryValue;
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = Q/Îµâ‚€ = ${flux.toExponential(3)} NÂ·mÂ²/C (çƒå£³å¤–)`;
                    } else {
                        // çƒå£³å†…éƒ¨ï¼šé«˜æ–¯é¢åŒ…å›´çš„ç”µè·ä¸ºé›¶
                        enclosedCharge = 0;
                        theoryValue = 0;
                        flux = 0;
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = 0 (çƒå£³å†…æ— ç”µè·)`;
                    }
                    break;
                case 'cylinder':
                    const lambda = params.cylinder.lambda;
                    const length = 8;
                    const gaussRho = params.cylinder.gaussR;
                    if (gaussRho >= params.cylinder.R) {
                        enclosedCharge = lambda * length;
                        theoryValue = enclosedCharge / EPSILON0;
                        flux = theoryValue;
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = Î»L/Îµâ‚€ = ${flux.toExponential(3)} NÂ·mÂ²/C (æŸ±å¤–)`;
                    } else {
                        enclosedCharge = lambda * length * Math.pow(gaussRho / params.cylinder.R, 2);
                        theoryValue = enclosedCharge / EPSILON0;
                        flux = theoryValue;
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = Q_enc/Îµâ‚€ = (Î»LÂ·ÏÂ²/RÂ²)/Îµâ‚€ = ${flux.toExponential(3)} NÂ·mÂ²/C (æŸ±å†…)`;
                    }
                    break;
                case 'cylinderShell':
                    const lambdaShell = params.cylinderShell.lambda;
                    const lengthShell = 8;
                    const gaussRhoShell = params.cylinderShell.gaussR;
                    if (gaussRhoShell >= params.cylinderShell.R) {
                        enclosedCharge = lambdaShell * lengthShell;
                        theoryValue = enclosedCharge / EPSILON0;
                        flux = theoryValue;
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = Î»L/Îµâ‚€ = ${flux.toExponential(3)} NÂ·mÂ²/C (åœ†æŸ±å£³å¤–)`;
                    } else {
                        // åœ†æŸ±å£³å†…éƒ¨ï¼šé«˜æ–¯é¢åŒ…å›´çš„ç”µè·ä¸ºé›¶
                        enclosedCharge = 0;
                        theoryValue = 0;
                        flux = 0;
                        formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = 0 (åœ†æŸ±å£³å†…æ— ç”µè·)`;
                    }
                    break;
                case 'plane':
                    const sigma = params.plane.sigma;
                    const gaussRadius = Math.min(params.plane.size / 3, 2.5);
                    const area = Math.PI * gaussRadius * gaussRadius;
                    enclosedCharge = sigma * area;
                    theoryValue = enclosedCharge / EPSILON0;
                    const E = sigma / (2 * EPSILON0);
                    flux = 2 * E * area;
                    formulaText = `âˆ®<sub>S</sub> <b>E</b> Â· d<b>S</b> = ÏƒS/Îµâ‚€ = ${flux.toExponential(3)} NÂ·mÂ²/C`;
                    break;
            }

            // æ›´æ–°æ˜¾ç¤º
            document.getElementById('fluxValue').textContent = flux.toExponential(3) + " NÂ·mÂ²/C";
            document.getElementById('theoryValue').textContent = theoryValue.toExponential(3) + " NÂ·mÂ²/C";
            document.getElementById('gaussProofDisplay').innerHTML = formulaText;
        }

        // ========== åŠ¨ç”»å¾ªç¯ ==========
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (gaussianSurface && showGaussian) {
                gaussianSurface.rotation.y += 0.003;
            }
            renderer.render(scene, camera);
        }

        // ========== äº‹ä»¶ç›‘å¬ ==========
        function initEventListeners() {
            document.getElementById('chargeType').addEventListener('change', function(e) {
                currentChargeType = e.target.value;
                const isPointSphere = currentChargeType === 'point' || currentChargeType === 'sphere';
                const isPoint = currentChargeType === 'point';
                const isSphere = currentChargeType === 'sphere';
                const isSphereShell = currentChargeType === 'sphereShell';
                const isCylinder = currentChargeType === 'cylinder';
                const isCylinderShell = currentChargeType === 'cylinderShell';
                
                // æ§åˆ¶ä¸»è¦å‚æ•°é¢æ¿çš„æ˜¾ç¤º
                document.getElementById('pointSphereControls').style.display = isPointSphere ? 'block' : 'none';
                document.getElementById('sphereShellControls').style.display = isSphereShell ? 'block' : 'none';
                document.getElementById('cylinderControls').style.display = isCylinder ? 'block' : 'none';
                document.getElementById('cylinderShellControls').style.display = isCylinderShell ? 'block' : 'none';
                document.getElementById('planeControls').style.display = currentChargeType === 'plane' ? 'block' : 'none';
                
                // ä¿®æ”¹ï¼šç‚¹ç”µè·æ¨¡å¼ä¸‹éšè—çƒä½“åŠå¾„è°ƒèŠ‚
                const sphereRadiusControl = document.getElementById('sphereRadiusControl');
                if (sphereRadiusControl) {
                    sphereRadiusControl.style.display = isPoint ? 'none' : (isSphere ? 'block' : 'none');
                }
                
                // æ›´æ–°æ ‡ç­¾æ–‡å­—
                const radiusLabel = document.getElementById('radiusLabel');
                if (radiusLabel) {
                    if (currentChargeType === 'point') {
                        // ç‚¹ç”µè·æ¨¡å¼ä¸‹ä¸æ˜¾ç¤ºåŠå¾„æ ‡ç­¾
                    } else if (currentChargeType === 'sphere') {
                        radiusLabel.textContent = 'çƒä½“åŠå¾„ R (m)';
                    }
                }
                
                updateChargeObject();
                updateFieldLines();
                updateGaussianSurface();
                updatePhysicsData();
            });

            // ç‚¹ç”µè·/çƒä½“å‚æ•°
            document.getElementById('QSlider').addEventListener('input', function(e) {
                const rawValue = parseFloat(e.target.value);
                params.pointSphere.Q = rawValue * 1e-9;
                
                // æ›´æ–°æ»‘å—é¢œè‰²å’Œæ•°å€¼æ˜¾ç¤º
                updateSliderStyle('QSlider', rawValue, 'QIndicator');
                updateValueDisplay('QValue', rawValue);
                
                updateChargeObject();
                updateFieldLines();
                updatePhysicsData();
            });

            document.getElementById('RSlider').addEventListener('input', function(e) {
                params.pointSphere.R = parseFloat(e.target.value);
                document.getElementById('RValue').textContent = e.target.value;
                updateChargeObject();
                updateFieldLines();
                updateGaussianSurface();
                updatePhysicsData();
            });

            document.getElementById('gaussSphereSlider').addEventListener('input', function(e) {
                params.pointSphere.gaussR = parseFloat(e.target.value);
                document.getElementById('gaussSphereValue').textContent = e.target.value;
                updateGaussianSurface();
                updatePhysicsData();
            });

            // çƒå£³å‚æ•°
            document.getElementById('QShellSlider').addEventListener('input', function(e) {
                const rawValue = parseFloat(e.target.value);
                params.sphereShell.Q = rawValue * 1e-9;
                
                updateSliderStyle('QShellSlider', rawValue, 'QShellIndicator');
                updateValueDisplay('QShellValue', rawValue);
                
                updateChargeObject();
                updateFieldLines();
                updatePhysicsData();
            });

            document.getElementById('sphereShellRSlider').addEventListener('input', function(e) {
                params.sphereShell.R = parseFloat(e.target.value);
                document.getElementById('sphereShellRValue').textContent = e.target.value;
                updateChargeObject();
                updateFieldLines();
                updateGaussianSurface();
                updatePhysicsData();
            });

            document.getElementById('gaussSphereShellSlider').addEventListener('input', function(e) {
                params.sphereShell.gaussR = parseFloat(e.target.value);
                document.getElementById('gaussSphereShellValue').textContent = e.target.value;
                updateGaussianSurface();
                updatePhysicsData();
            });

            // åœ†æŸ±ä½“å‚æ•°
            document.getElementById('lambdaSlider').addEventListener('input', function(e) {
                const rawValue = parseFloat(e.target.value);
                params.cylinder.lambda = rawValue * 1e-9;
                
                updateSliderStyle('lambdaSlider', rawValue, 'lambdaIndicator');
                updateValueDisplay('lambdaValue', rawValue);
                
                updateChargeObject();
                updateFieldLines();
                updatePhysicsData();
            });

            document.getElementById('cylinderRSlider').addEventListener('input', function(e) {
                params.cylinder.R = parseFloat(e.target.value);
                document.getElementById('cylinderRValue').textContent = e.target.value;
                updateChargeObject();
                updateFieldLines();
                updateGaussianSurface();
                updatePhysicsData();
            });

            document.getElementById('gaussCylinderSlider').addEventListener('input', function(e) {
                params.cylinder.gaussR = parseFloat(e.target.value);
                document.getElementById('gaussCylinderValue').textContent = e.target.value;
                updateGaussianSurface();
                updatePhysicsData();
            });

            // åœ†æŸ±å£³å‚æ•°
            document.getElementById('lambdaShellSlider').addEventListener('input', function(e) {
                const rawValue = parseFloat(e.target.value);
                params.cylinderShell.lambda = rawValue * 1e-9;
                
                updateSliderStyle('lambdaShellSlider', rawValue, 'lambdaShellIndicator');
                updateValueDisplay('lambdaShellValue', rawValue);
                
                updateChargeObject();
                updateFieldLines();
                updatePhysicsData();
            });

            document.getElementById('cylinderShellRSlider').addEventListener('input', function(e) {
                params.cylinderShell.R = parseFloat(e.target.value);
                document.getElementById('cylinderShellRValue').textContent = e.target.value;
                updateChargeObject();
                updateFieldLines();
                updateGaussianSurface();
                updatePhysicsData();
            });

            document.getElementById('gaussCylinderShellSlider').addEventListener('input', function(e) {
                params.cylinderShell.gaussR = parseFloat(e.target.value);
                document.getElementById('gaussCylinderShellValue').textContent = e.target.value;
                updateGaussianSurface();
                updatePhysicsData();
            });

            // å¹³é¢å‚æ•°
            document.getElementById('sigmaSlider').addEventListener('input', function(e) {
                const rawValue = parseFloat(e.target.value);
                params.plane.sigma = rawValue * 1e-9;
                
                updateSliderStyle('sigmaSlider', rawValue, 'sigmaIndicator');
                updateValueDisplay('sigmaValue', rawValue);
                
                updateChargeObject();
                updateFieldLines();
                updatePhysicsData();
            });

            document.getElementById('planeSizeSlider').addEventListener('input', function(e) {
                params.plane.size = parseFloat(e.target.value);
                document.getElementById('planeSizeValue').textContent = e.target.value;
                updateChargeObject();
                updateFieldLines();
                updatePhysicsData();
            });

            // æ§åˆ¶æŒ‰é’®
            document.getElementById('resetView').addEventListener('click', function() {
                controls.reset();
                camera.position.set(6, 4, 6);
            });
            
            document.getElementById('toggleFieldLines').addEventListener('click', function() {
                showFieldLines = !showFieldLines;
                document.getElementById('fieldLineStatus').textContent = showFieldLines ? 'æ˜¾ç¤º' : 'éšè—';
                updateFieldLines();
            });
            
            document.getElementById('toggleGaussian').addEventListener('click', function() {
                showGaussian = !showGaussian;
                document.getElementById('gaussianStatus').textContent = showGaussian ? 'æ˜¾ç¤º' : 'éšè—';
                updateGaussianSurface();
            });

            window.addEventListener('resize', function() {
                const container = document.getElementById('canvas-container');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }

        // ========== åˆå§‹åŒ– ==========
        function init() {
            initThreeJS();
            initEventListeners();
            
            // åˆå§‹æ›´æ–°æ»‘å—æ ·å¼
            updateSliderStyle('QSlider', 1, 'QIndicator');
            updateSliderStyle('QShellSlider', 1, 'QShellIndicator');
            updateSliderStyle('lambdaSlider', 1, 'lambdaIndicator');
            updateSliderStyle('lambdaShellSlider', 1, 'lambdaShellIndicator');
            updateSliderStyle('sigmaSlider', 1, 'sigmaIndicator');
            
            // åˆå§‹éšè—çƒä½“åŠå¾„æ§åˆ¶ï¼ˆé»˜è®¤ä¸ºç‚¹ç”µè·ï¼‰
            const sphereRadiusControl = document.getElementById('sphereRadiusControl');
            if (sphereRadiusControl) {
                sphereRadiusControl.style.display = 'none';
            }
            
            updatePhysicsData();
            document.getElementById('pointSphereControls').style.display = 'block';
        }
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>